{% extends 'api/base.html' %}
{% load static %}

{% block title %}Carousel Editor - Customize Your Slides{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/editor.css' %}">
<style>
    /* Additional styles for image handling */
    .slide-item-preview-img {
        width: 100%;
        height: 60px;
        background-size: cover;
        background-position: center;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.75rem;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    
    .image-preview {
        width: 100%;
        height: 120px;
        background: var(--light);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 0.5rem;
        border: 2px solid var(--light-gray);
    }
    
    .image-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .canvas-container {
        position: relative;
        background: #f5f5f5;
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: var(--shadow);
        min-height: 500px;
    }
    
    #konvaContainer {
        width: 100%;
        height: 100%;
        background: white;
    }
    
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        backdrop-filter: blur(5px);
    }
    
    .loading-content {
        text-align: center;
        max-width: 400px;
        padding: 2rem;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-lg);
    }
    
    .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid var(--light-gray);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 2rem;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>
{% endblock %}

{% block content %}
<div class="editor-container">
    {% if error %}
    <div class="error-message">
        <div class="error-content">
            <i class="fas fa-exclamation-triangle"></i>
            <h2>{{ error }}</h2>
            <a href="/" class="btn btn-primary">
                <i class="fas fa-home"></i> Go to Homepage
            </a>
        </div>
    </div>
    {% else %}
    <!-- Sidebar -->
    <div class="editor-sidebar">
        <div class="sidebar-header">
            <h3><i class="fas fa-layer-group"></i> Slides</h3>
            <button id="addSlide" class="btn btn-sm">
                <i class="fas fa-plus"></i> Add
            </button>
        </div>
        
        <div class="slides-list" id="slidesList">
            <!-- Slides will be loaded dynamically -->
            <div class="loading-slides">
                <div class="loading-spinner small"></div>
                <p>Loading slides...</p>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h4><i class="fas fa-paint-brush"></i> Design Tools</h4>
            <div class="design-tools">
                <div class="tool-group">
                    <label>Background</label>
                    <input type="color" id="bgColor" value="#FFFFFF">
                </div>
                <div class="tool-group">
                    <label>Font Color</label>
                    <input type="color" id="fontColor" value="#000000">
                </div>
                <div class="tool-group">
                    <label>Font Family</label>
                    <select id="fontFamily">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Poppins" selected>Poppins</option>
                        <option value="Inter">Inter</option>
                        <option value="Montserrat">Montserrat</option>
                    </select>
                </div>
                <div class="tool-group">
                    <label>Layout</label>
                    <select id="layout">
                        <option value="centered" selected>Centered</option>
                        <option value="left">Left Aligned</option>
                        <option value="split">Split Screen</option>
                        <option value="top">Top Aligned</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h4><i class="fas fa-image"></i> Generate Image</h4>
            <div class="image-generator">
                <textarea id="imagePrompt" placeholder="Describe the Canva-style background you want..."></textarea>
                <button id="generateImageBtn" class="btn btn-secondary">
                    <i class="fas fa-magic"></i> Generate & Apply
                </button>
                <div class="form-hint">Image will be applied to current slide</div>
                <div id="imagePreview" class="image-preview">
                    <div class="empty-preview">
                        <i class="fas fa-image"></i>
                        <p>Generated image will appear here</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="sidebar-actions">
            <button id="saveDesign" class="btn btn-primary">
                <i class="fas fa-save"></i> Save Slide
            </button>
            <button id="saveAllDesigns" class="btn btn-secondary">
                <i class="fas fa-save"></i> Save All
            </button>
            <button id="exportBtn" class="btn btn-success">
                <i class="fas fa-download"></i> Export All
            </button>
        </div>
    </div>
    
    <!-- Main Editor -->
    <div class="editor-main">
        <div class="editor-header">
            <div class="editor-nav">
                <button id="prevSlide" class="btn btn-sm">
                    <i class="fas fa-chevron-left"></i> Previous
                </button>
                <span id="currentSlide">Slide <span id="currentSlideNumber">1</span> of <span id="totalSlides">0</span></span>
                <button id="nextSlide" class="btn btn-sm">
                    Next <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            <div class="editor-tools">
                <button id="undo" class="btn btn-sm" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>
                <button id="redo" class="btn btn-sm" title="Redo">
                    <i class="fas fa-redo"></i>
                </button>
                <button id="zoomIn" class="btn btn-sm" title="Zoom In">
                    <i class="fas fa-search-plus"></i>
                </button>
                <button id="zoomOut" class="btn btn-sm" title="Zoom Out">
                    <i class="fas fa-search-minus"></i>
                </button>
                <button id="resetView" class="btn btn-sm" title="Reset View">
                    <i class="fas fa-expand"></i>
                </button>
                <button id="fullscreen" class="btn btn-sm" title="Fullscreen">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
            </div>
        </div>
        
        <div class="canvas-container">
            <div id="konvaContainer"></div>
            <div id="emptyState" class="empty-state">
                <i class="fas fa-layer-group"></i>
                <h3>No Slides Loaded</h3>
                <p>Generate a carousel first or load existing slides</p>
            </div>
        </div>
        
        <div class="slide-properties">
            <h4><i class="fas fa-edit"></i> Edit Content</h4>
            <div class="properties-form">
                <div class="form-group">
                    <label>Title</label>
                    <input type="text" id="slideTitle" placeholder="Slide title" class="form-control">
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="slideDescription" placeholder="Slide description" rows="3" class="form-control"></textarea>
                </div>
                <div class="form-group">
                    <label>Image Prompt</label>
                    <textarea id="slideImagePrompt" placeholder="Describe the background image" rows="2" class="form-control"></textarea>
                </div>
                <div class="form-group">
                    <label>Generated Image URL</label>
                    <input type="text" id="generatedImageUrl" placeholder="No image generated yet" class="form-control" readonly>
                    <div class="form-hint">This will be updated when you generate an image</div>
                </div>
                <button id="updateContent" class="btn btn-primary">
                    <i class="fas fa-sync"></i> Update Slide
                </button>
                <button id="regenerateSlide" class="btn btn-warning">
                    <i class="fas fa-robot"></i> Regenerate with AI
                </button>
            </div>
        </div>
    </div>
    {% endif %}
</div>

<!-- Loading overlay -->
<div id="editorLoading" class="loading-overlay" style="display: none;">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <h3>Loading Editor</h3>
        <p>Preparing your carousel for editing...</p>
        <div class="progress-bar">
            <div class="progress"></div>
        </div>
    </div>
</div>

<!-- CSRF Token -->
{% csrf_token %}
{% endblock %}

{% block extra_js %}
<script src="https://unpkg.com/konva@8/konva.min.js"></script>
<script>
// CSRF Token helper
function getCSRFToken() {
    return document.que6rySelector('[name=csrfmiddlewaretoken]').value;
}

class CarouselEditor {
    constructor(projectId) {
        this.stage = null;
        this.layer = null;
        this.currentSlide = 0;
        this.slides = [];
        this.projectId = projectId;
        this.isLoading = true;
        this.undoStack = [];
        this.redoStack = [];
        this.scale = 1;
        
        this.init();
    }
    
    async init() {
        this.showLoading();
        
        try {
            // Load slides from backend
            await this.loadSlidesFromBackend();
            
            if (this.slides.length > 0) {
                // Initialize Konva
                await this.initKonva();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Render first slide
                this.renderSlide(0);
                this.renderSlidesList();
                
                console.log('âœ… Editor initialized with', this.slides.length, 'slides');
            } else {
                this.showEmptyState();
                console.warn('No slides found for project', this.projectId);
            }
        } catch (error) {
            console.error('Editor initialization error:', error);
            toastr.error('Failed to initialize editor: ' + error.message);
        } finally {
            this.hideLoading();
        }
    }
    
    showLoading() {
        document.getElementById('editorLoading').style.display = 'flex';
    }
    
    hideLoading() {
        document.getElementById('editorLoading').style.display = 'none';
    }
    
    showEmptyState() {
        document.getElementById('emptyState').style.display = 'flex';
        document.getElementById('currentSlide').textContent = 'No slides available';
    }
    
    hideEmptyState() {
        document.getElementById('emptyState').style.display = 'none';
    }
    
    async loadSlidesFromBackend() {
        try {
            console.log('Loading slides for project:', this.projectId);
            const response = await fetch(`/api/project/${this.projectId}/slides/`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('API Response:', data);
            
            if (data.success && data.slides && Array.isArray(data.slides)) {
                this.slides = data.slides;
                document.getElementById('totalSlides').textContent = this.slides.length;
                
                // Log each slide for debugging
                this.slides.forEach((slide, index) => {
                    console.log(`Slide ${index + 1}:`, {
                        id: slide.id,
                        title: slide.title,
                        hasImage: !!slide.generated_image,
                        bgColor: slide.background_color,
                        fontColor: slide.font_color
                    });
                });
            } else {
                throw new Error(data.error || 'Invalid response format');
            }
        } catch (error) {
            console.error('Error loading slides:', error);
            toastr.error('Failed to load slides: ' + error.message);
            throw error;
        }
    }
    
    renderSlidesList() {
        const slidesList = document.getElementById('slidesList');
        slidesList.innerHTML = '';
        
        this.slides.forEach((slide, index) => {
            const slideItem = document.createElement('div');
            slideItem.className = `slide-item ${index === this.currentSlide ? 'active' : ''}`;
            slideItem.dataset.index = index;
            
            // Create background style
            let backgroundStyle = `background-color: ${slide.background_color || '#FFFFFF'};`;
            
            // If slide has generated image, use it as background
            if (slide.generated_image) {
                const imageUrl = `/media/${slide.generated_image}`;
                backgroundStyle = `background-image: url('${imageUrl}'); background-size: cover; background-position: center;`;
            }
            
            slideItem.innerHTML = `
                <div class="slide-item-header">
                    <div class="slide-item-title" title="${slide.title || 'Slide ' + (index + 1)}">
                        ${slide.title ? slide.title.substring(0, 20) : 'Slide ' + (index + 1)}
                        ${slide.title && slide.title.length > 20 ? '...' : ''}
                    </div>
                    <span class="slide-number">${index + 1}</span>
                </div>
                <div class="slide-item-preview" style="${backgroundStyle}; color: ${slide.font_color || '#000000'};">
                    ${slide.generated_image ? '<i class="fas fa-image"></i>' : ''}
                    ${!slide.generated_image && slide.title ? slide.title.substring(0, 15) : 'Preview'}
                </div>
            `;
            
            slideItem.addEventListener('click', () => {
                this.currentSlide = index;
                this.renderSlide(index);
                this.updateSlidesList();
            });
            
            slidesList.appendChild(slideItem);
        });
    }
    
    updateSlidesList() {
        document.querySelectorAll('.slide-item').forEach((item, index) => {
            item.classList.toggle('active', index === this.currentSlide);
        });
    }
    
    async initKonva() {
        const container = document.getElementById('konvaContainer');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        this.stage = new Konva.Stage({
            container: 'konvaContainer',
            width: width,
            height: height
        });
        
        this.layer = new Konva.Layer();
        this.stage.add(this.layer);
        
        this.hideEmptyState();
        
        // Add transformer for editing
        this.transformer = new Konva.Transformer({
            rotateEnabled: true,
            borderStroke: '#6366f1',
            borderStrokeWidth: 2,
            anchorStroke: '#6366f1',
            anchorFill: 'white',
            anchorSize: 10
        });
        this.layer.add(this.transformer);
        
        // Handle stage scaling
        this.stage.on('wheel', (e) => {
            e.evt.preventDefault();
            const scaleBy = 1.1;
            const oldScale = this.stage.scaleX();
            const pointer = this.stage.getPointerPosition();
            
            const mousePointTo = {
                x: (pointer.x - this.stage.x()) / oldScale,
                y: (pointer.y - this.stage.y()) / oldScale
            };
            
            const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
            
            this.stage.scale({ x: newScale, y: newScale });
            
            const newPos = {
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale
            };
            
            this.stage.position(newPos);
            this.scale = newScale;
            this.layer.batchDraw();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('konvaContainer');
            this.stage.width(container.clientWidth);
            this.stage.height(container.clientHeight);
            this.layer.batchDraw();
        });
    }
    
    async renderSlide(slideIndex) {
        if (slideIndex < 0 || slideIndex >= this.slides.length) {
            console.error('Invalid slide index:', slideIndex);
            return;
        }
        
        console.log('Rendering slide:', slideIndex, this.slides[slideIndex]);
        
        // Clear the layer
        this.layer.destroyChildren();
        
        const slide = this.slides[slideIndex];
        const width = this.stage.width();
        const height = this.stage.height();
        
        // Save current state for undo
        this.saveState();
        
        // Create background based on available data
        if (slide.generated_image) {
            // Load and display generated image
            const imageUrl = `/media/${slide.generated_image}`;
            console.log('Loading generated image:', imageUrl);
            
            await this.loadImageAsBackground(imageUrl, width, height);
        } else {
            // Use background color
            console.log('Using background color:', slide.background_color);
            const background = new Konva.Rect({
                x: 0,
                y: 0,
                width: width,
                height: height,
                fill: slide.background_color || '#FFFFFF',
                stroke: '#e5e7eb',
                strokeWidth: 1,
                name: 'background'
            });
            this.layer.add(background);
        }
        
        // Create title text
        this.titleNode = new Konva.Text({
    x: width / 2,
    y: height / 3 - 40,
    text: slide.title || `Slide ${slideIndex + 1}`,
    fontSize: 48,
    fontFamily: 'Poppins',
    fill: slide.font_color || '#000000',
    align: 'center',
    width: width * 0.8,
    padding: 20,
    lineHeight: 1.2,
    name: 'title'
});
this.titleNode.offsetX(this.titleNode.width() / 2);

this.descNode = new Konva.Text({
    x: width / 2,
    y: height / 2 + 20,
    text: slide.description || 'Add description here',
    fontSize: 24,
    fontFamily: 'Inter',
    fill: slide.font_color || '#000000',
    align: 'center',
    width: width * 0.7,
    padding: 20,
    lineHeight: 1.4,
    name: 'description'
});
this.descNode.offsetX(this.descNode.width() / 2);

this.layer.add(this.titleNode, this.descNode);

// ðŸ”¥ LIVE TEXT UPDATE (NO SAVE BUTTON)

const titleInput = document.getElementById('slideTitle');
const descInput = document.getElementById('slideDescription');

titleInput.addEventListener('input', (e) => {
    if (!this.slides[this.currentSlide] || !this.titleNode) return;

    const value = e.target.value;
    this.slides[this.currentSlide].title = value;
    this.titleNode.text(value);
    this.layer.batchDraw();
    this.renderSlidesList();
});

descInput.addEventListener('input', (e) => {
    if (!this.slides[this.currentSlide] || !this.descNode) return;

    const value = e.target.value;
    this.slides[this.currentSlide].description = value;
    this.descNode.text(value);
    this.layer.batchDraw();
});

        
        // Update UI controls with slide data
        this.updateUIControls(slide, slideIndex);
        
        // Draw everything
        this.layer.batchDraw();
        
        console.log('âœ… Slide rendered successfully');
    }
    
    async loadImageAsBackground(imageUrl, width, height) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                const bgImage = new Konva.Image({
                    x: 0,
                    y: 0,
                    image: img,
                    width: width,
                    height: height,
                    name: 'backgroundImage'
                });
                
                this.layer.add(bgImage);
                bgImage.moveToBottom();
                resolve();
            };
            
            img.onerror = (error) => {
                console.error('Failed to load image:', imageUrl, error);
                // Fallback to color background
                const background = new Konva.Rect({
                    x: 0,
                    y: 0,
                    width: width,
                    height: height,
                    fill: this.slides[this.currentSlide].background_color || '#FFFFFF',
                    stroke: '#e5e7eb',
                    strokeWidth: 1,
                    name: 'background'
                });
                this.layer.add(background);
                reject(error);
            };
            
            img.src = imageUrl;
        });
    }
    
    updateUIControls(slide, slideIndex) {
        // Update slide counter
        document.getElementById('currentSlideNumber').textContent = slideIndex + 1;
        document.getElementById('currentSlide').textContent = 
            `Slide ${slideIndex + 1} of ${this.slides.length}`;
        
        // Update form fields
        document.getElementById('slideTitle').value = slide.title || '';
        document.getElementById('slideDescription').value = slide.description || '';
        document.getElementById('slideImagePrompt').value = slide.image_prompt || '';
        document.getElementById('bgColor').value = slide.background_color || '#FFFFFF';
        document.getElementById('fontColor').value = slide.font_color || '#000000';
        
        // Update generated image URL if exists
        if (slide.generated_image) {
            const imageUrl = `/media/${slide.generated_image}`;
            document.getElementById('generatedImageUrl').value = imageUrl;
            
            // Also update image preview
            const imagePreview = document.getElementById('imagePreview');
            imagePreview.innerHTML = `<img src="${imageUrl}" alt="Generated" style="width:100%;height:100%;object-fit:cover">`;
        } else {
            document.getElementById('generatedImageUrl').value = '';
            const imagePreview = document.getElementById('imagePreview');
            imagePreview.innerHTML = `
                <div class="empty-preview">
                    <i class="fas fa-image"></i>
                    <p>No image generated yet</p>
                </div>
            `;
        }
    }
    
    makeEditable(textNode, fieldName) {
        textNode.on('dblclick', () => {
            const textPosition = textNode.absolutePosition();
            const stageBox = this.stage.container().getBoundingClientRect();
            
            const areaPosition = {
                x: stageBox.left + textPosition.x,
                y: stageBox.top + textPosition.y
            };
            
            const textarea = document.createElement('textarea');
            document.body.appendChild(textarea);
            
            textarea.value = textNode.text();
            textarea.style.position = 'absolute';
            textarea.style.top = areaPosition.y + 'px';
            textarea.style.left = areaPosition.x + 'px';
            textarea.style.width = textNode.width() + 'px';
            textarea.style.height = textNode.height() + 'px';
            textarea.style.fontSize = textNode.fontSize() + 'px';
            textarea.style.border = '2px solid #6366f1';
            textarea.style.padding = '5px';
            textarea.style.margin = '0px';
            textarea.style.overflow = 'hidden';
            textarea.style.background = 'white';
            textarea.style.outline = 'none';
            textarea.style.resize = 'none';
            textarea.style.lineHeight = textNode.lineHeight();
            textarea.style.fontFamily = textNode.fontFamily();
            textarea.style.transformOrigin = 'left top';
            textarea.style.textAlign = textNode.align();
            textarea.style.color = textNode.fill();
            textarea.style.zIndex = '1000';
            textarea.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';
            textarea.focus();
            
            const transform = textNode.getAbsoluteTransform().copy();
            transform.invert();
            const textareaOffset = transform.point(textNode.offset());
            
            textarea.style.top = (areaPosition.y - textareaOffset.y) + 'px';
            textarea.style.left = (areaPosition.x - textareaOffset.x) + 'px';
            
            const removeTextarea = () => {
                textarea.removeEventListener('blur', removeTextarea);
                textarea.remove();
                window.removeEventListener('click', handleOutsideClick);
                
                // Update slide data
                const newText = textarea.value;
                this.slides[this.currentSlide][fieldName === 'title' ? 'title' : 'description'] = newText;
                textNode.text(newText);
                
                // Update form field
                if (fieldName === 'title') {
                    document.getElementById('slideTitle').value = newText;
                } else {
                    document.getElementById('slideDescription').value = newText;
                }
                
                this.layer.batchDraw();
                toastr.success(`${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} updated`);
            };
            
            textarea.addEventListener('blur', removeTextarea);
            
            const handleOutsideClick = (e) => {
                if (e.target !== textarea) {
                    removeTextarea();
                }
            };
            
            setTimeout(() => {
                window.addEventListener('click', handleOutsideClick);
            });
        });
    }
    
    saveState() {
        // Save current state for undo/redo
        if (this.slides[this.currentSlide]) {
            this.undoStack.push(JSON.stringify(this.slides[this.currentSlide]));
            if (this.undoStack.length > 50) this.undoStack.shift();
            this.redoStack = [];
        }
    }
    
    setupEventListeners() {
        // Navigation
        document.getElementById('prevSlide').addEventListener('click', () => {
            if (this.currentSlide > 0) {
                this.currentSlide--;
                this.renderSlide(this.currentSlide);
                this.updateSlidesList();
            }
        });
        
        document.getElementById('nextSlide').addEventListener('click', () => {
            if (this.currentSlide < this.slides.length - 1) {
                this.currentSlide++;
                this.renderSlide(this.currentSlide);
                this.updateSlidesList();
            }
        });
        
        // Design controls
        document.getElementById('bgColor').addEventListener('change', (e) => {
            if (this.slides[this.currentSlide]) {
                this.slides[this.currentSlide].background_color = e.target.value;
                this.renderSlide(this.currentSlide);
                this.renderSlidesList();
                toastr.info('Background color updated');
            }
        });
        
        document.getElementById('fontColor').addEventListener('change', (e) => {
            if (this.slides[this.currentSlide]) {
                this.slides[this.currentSlide].font_color = e.target.value;
                this.renderSlide(this.currentSlide);
                toastr.info('Font color updated');
            }
        });
        
        document.getElementById('fontFamily').addEventListener('change', (e) => {
            if (this.layer && this.layer.children.length > 1) {
                const textNodes = this.layer.children.filter(child => 
                    child.className === 'Text' && (child.name() === 'title' || child.name() === 'description')
                );
                textNodes.forEach(node => {
                    node.fontFamily(e.target.value);
                });
                this.layer.batchDraw();
                toastr.info('Font family updated');
            }
        });
        
        document.getElementById('layout').addEventListener('change', (e) => {
            if (this.layer && this.slides[this.currentSlide]) {
                const layout = e.target.value;
                const title = this.layer.findOne('.title');
                const description = this.layer.findOne('.description');
                
                if (title && description) {
                    const width = this.stage.width();
                    const height = this.stage.height();
                    
                    switch(layout) {
                        case 'centered':
                            title.x(width / 2);
                            title.y(height / 3 - 40);
                            description.x(width / 2);
                            description.y(height / 2 + 20);
                            break;
                        case 'left':
                            title.x(width * 0.1);
                            title.y(height / 3 - 40);
                            description.x(width * 0.1);
                            description.y(height / 2 + 20);
                            break;
                        case 'split':
                            title.x(width * 0.1);
                            title.y(height / 3);
                            description.x(width * 0.6);
                            description.y(height / 3);
                            break;
                        case 'top':
                            title.x(width / 2);
                            title.y(height * 0.2);
                            description.x(width / 2);
                            description.y(height * 0.4);
                            break;
                    }
                    
                    title.offsetX(title.width() / 2);
                    description.offsetX(description.width() / 2);
                    this.layer.batchDraw();
                    toastr.info('Layout updated');
                }
            }
        });
        
        // Content update
        document.getElementById('updateContent').addEventListener('click', () => {
            if (this.slides[this.currentSlide]) {
                const slide = this.slides[this.currentSlide];
                slide.title = document.getElementById('slideTitle').value;
                slide.description = document.getElementById('slideDescription').value;
                slide.image_prompt = document.getElementById('slideImagePrompt').value;
                slide.background_color = document.getElementById('bgColor').value;
                slide.font_color = document.getElementById('fontColor').value;
                
                this.renderSlide(this.currentSlide);
                this.renderSlidesList();
                toastr.success('Slide content updated');
            }
        });
        
        // Regenerate slide with AI
        document.getElementById('regenerateSlide').addEventListener('click', async () => {
            if (!this.slides[this.currentSlide]) {
                toastr.error('No slide selected');
                return;
            }
            
            const slide = this.slides[this.currentSlide];
            const topic = slide.title || 'Slide content';
            
            toastr.info('Regenerating slide content with AI...');
            
            try {
                const response = await fetch('/api/regenerate-slide/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({
                        slide_id: slide.id,
                        topic: topic
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Update slide with new content
                    Object.assign(slide, data.slide);
                    this.renderSlide(this.currentSlide);
                    this.renderSlidesList();
                    toastr.success('Slide regenerated with AI!');
                } else {
                    toastr.error(data.error || 'Failed to regenerate slide');
                }
            } catch (error) {
                console.error('Error regenerating slide:', error);
                toastr.error('Failed to regenerate slide');
            }
        });
        
        // Generate image
        document.getElementById('generateImageBtn').addEventListener('click', async () => {
            const prompt = document.getElementById('imagePrompt').value;
            if (!prompt.trim()) {
                toastr.error('Please enter an image description');
                return;
            }
            
            if (!this.slides[this.currentSlide]) {
                toastr.error('No slide selected');
                return;
            }
            
            const slide = this.slides[this.currentSlide];
            
            toastr.info('Generating Canva-style image...');
            
            try {
                const response = await fetch('/api/generate-and-apply-image/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({ 
                        prompt: prompt,
                        slide_id: slide.id,
                        platform: 'instagram'
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Update slide with generated image
                    slide.generated_image = data.filename;
                    slide.image_prompt = prompt;
                    
                    // Update UI
                    document.getElementById('slideImagePrompt').value = prompt;
                    document.getElementById('generatedImageUrl').value = data.image_url;
                    
                    // Update image preview
                    const imagePreview = document.getElementById('imagePreview');
                    imagePreview.innerHTML = `<img src="${data.image_url}" alt="Generated" style="width:100%;height:100%;object-fit:cover">`;
                    
                    // Re-render slide with new image
                    await this.renderSlide(this.currentSlide);
                    this.renderSlidesList();
                    
                    toastr.success('Canva image generated and applied to slide!');
                } else {
                    toastr.error(data.error || 'Failed to generate image');
                }
            } catch (error) {
                console.error('Error generating image:', error);
                toastr.error('Failed to generate image');
            }
        });
        
        // Save design
        document.getElementById('saveDesign').addEventListener('click', async () => {
            if (this.slides[this.currentSlide]) {
                const slide = this.slides[this.currentSlide];
                
                try {
                    const response = await fetch('/api/save-design/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCSRFToken()
                        },
                        body: JSON.stringify({
                            slide_id: slide.id,
                            design_data: {
                                title: slide.title,
                                description: slide.description,
                                image_prompt: slide.image_prompt,
                                background_color: slide.background_color,
                                font_color: slide.font_color,
                                generated_image: slide.generated_image
                            }
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        toastr.success('Slide design saved successfully');
                    } else {
                        toastr.error(data.error || 'Failed to save design');
                    }
                } catch (error) {
                    console.error('Error saving design:', error);
                    toastr.error('Failed to save design');
                }
            }
        });
        
        // Save all designs
        document.getElementById('saveAllDesigns').addEventListener('click', async () => {
            if (this.slides.length === 0) {
                toastr.error('No slides to save');
                return;
            }
            
            toastr.info('Saving all slides...');
            
            try {
                let savedCount = 0;
                let errorCount = 0;
                
                for (const slide of this.slides) {
                    try {
                        const response = await fetch('/api/save-design/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCSRFToken()
                            },
                            body: JSON.stringify({
                                slide_id: slide.id,
                                design_data: {
                                    title: slide.title,
                                    description: slide.description,
                                    image_prompt: slide.image_prompt,
                                    background_color: slide.background_color,
                                    font_color: slide.font_color,
                                    generated_image: slide.generated_image
                                }
                            })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            savedCount++;
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                    }
                }
                
                if (errorCount === 0) {
                    toastr.success(`All ${savedCount} slides saved successfully`);
                } else {
                    toastr.warning(`${savedCount} slides saved, ${errorCount} failed`);
                }
            } catch (error) {
                console.error('Error saving all designs:', error);
                toastr.error('Failed to save all designs');
            }
        });
        
        // Export
        document.getElementById('exportBtn').addEventListener('click', () => {
            this.exportSlides();
        });
        
        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', () => {
            this.zoom(1.2);
        });
        
        document.getElementById('zoomOut').addEventListener('click', () => {
            this.zoom(0.8);
        });
        
        document.getElementById('resetView').addEventListener('click', () => {
            this.stage.scale({ x: 1, y: 1 });
            this.stage.position({ x: 0, y: 0 });
            this.scale = 1;
            this.layer.batchDraw();
            toastr.info('View reset');
        });
        
        document.getElementById('fullscreen').addEventListener('click', () => {
            const container = document.getElementById('konvaContainer');
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => {
                    console.error('Error attempting to enable fullscreen:', err);
                });
            } else {
                document.exitFullscreen();
            }
        });
        
        // Undo/Redo
        document.getElementById('undo').addEventListener('click', () => {
            if (this.undoStack.length > 0) {
                const previousState = this.undoStack.pop();
                this.redoStack.push(JSON.stringify(this.slides[this.currentSlide]));
                this.slides[this.currentSlide] = JSON.parse(previousState);
                this.renderSlide(this.currentSlide);
                this.renderSlidesList();
                toastr.info('Undo applied');
            }
        });
        
        document.getElementById('redo').addEventListener('click', () => {
            if (this.redoStack.length > 0) {
                const nextState = this.redoStack.pop();
                this.undoStack.push(JSON.stringify(this.slides[this.currentSlide]));
                this.slides[this.currentSlide] = JSON.parse(nextState);
                this.renderSlide(this.currentSlide);
                this.renderSlidesList();
                toastr.info('Redo applied');
            }
        });
        
        // Add slide button
        document.getElementById('addSlide').addEventListener('click', async () => {
            const newSlideNumber = this.slides.length + 1;
            const newSlide = {
                id: `new-${Date.now()}`,
                title: `New Slide ${newSlideNumber}`,
                description: 'Add your content here',
                image_prompt: '',
                background_color: '#FFFFFF',
                font_color: '#000000',
                generated_image: null
            };
            
            // Add to local array
            this.slides.push(newSlide);
            this.currentSlide = this.slides.length - 1;
            
            // Update UI
            document.getElementById('totalSlides').textContent = this.slides.length;
            
            // Render the new slide
            await this.renderSlide(this.currentSlide);
            this.renderSlidesList();
            
            toastr.success('New slide added');
        });
    }
    
    zoom(factor) {
        const oldScale = this.stage.scaleX();
        const newScale = oldScale * factor;
        
        const center = {
            x: this.stage.width() / 2,
            y: this.stage.height() / 2
        };
        
        const relatedTo = {
            x: (center.x - this.stage.x()) / oldScale,
            y: (center.y - this.stage.y()) / oldScale
        };
        
        this.stage.scale({ x: newScale, y: newScale });
        
        const newPos = {
            x: center.x - relatedTo.x * newScale,
            y: center.y - relatedTo.y * newScale
        };
        
        this.stage.position(newPos);
        this.scale = newScale;
        this.layer.batchDraw();
    }
    
    async exportSlides() {
        if (this.slides.length === 0) {
            toastr.error('No slides to export');
            return;
        }
        
        toastr.info('Exporting slides as images...');
        
        // Export each slide
        for (let i = 0; i < this.slides.length; i++) {
            await this.exportSlide(i);
        }
        
        toastr.success('All slides exported successfully!');
    }
    
    async exportSlide(slideIndex) {
        // Switch to the slide
        this.currentSlide = slideIndex;
        await this.renderSlide(slideIndex);
        
        // Wait for render
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Export as image
        const dataURL = this.stage.toDataURL({
            mimeType: 'image/png',
            quality: 1.0,
            pixelRatio: 3
        });
        
        // Download
        const link = document.createElement('a');
        link.download = `carousel-slide-${slideIndex + 1}-${this.slides[slideIndex].title?.substring(0, 20) || 'slide'}.png`;
        link.href = dataURL;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Small delay between exports
        await new Promise(resolve => setTimeout(resolve, 200));
    }
}

// Initialize editor when page loads
document.addEventListener('DOMContentLoaded', () => {
    const pathParts = window.location.pathname.split('/');
    const projectId = pathParts[2];
    
    if (projectId && !isNaN(projectId)) {
        console.log('Initializing editor for project:', projectId);
        window.carouselEditor = new CarouselEditor(projectId);
    } else {
        console.error('Invalid project ID provided:', projectId);
        toastr.error('Invalid project ID. Please generate a carousel first.');
        setTimeout(() => {
            window.location.href = '/';
        }, 2000);
    }
});
</script>
{% endblock %}